module default {
  scalar type NotificationKind extending enum<Favourite, Follow, Repost, Quote>;

  global currentUserDisplayName: str;

  abstract type Record {
    required createdAt: datetime {
      readonly := true;
      rewrite insert using(datetime_of_statement());
      default := datetime_of_statement();
    }
  }

  type Account extending Record {
    required email: str {
      constraint exclusive;
      constraint min_len_value(3);
      constraint max_len_value(128);
    }
    required password: str {
      constraint min_len_value(8);
      constraint max_len_value(64);
    }
    required refreshTokenVersion: int32 {
      constraint min_value(0);
      rewrite insert using(0);
      default := 0;
    }
  }

  type User extending Record {
    required account: Account {
      on source delete delete target;
      constraint exclusive;
    }
    required displayName: str {
      constraint exclusive;
      constraint min_len_value(3);
      constraint max_len_value(16);
    }
    required name: str {
      constraint exclusive;
      constraint min_len_value(3);
      constraint max_len_value(64);
    }
    description: str {
      constraint max_len_value(256);
    }
    location: str {
      constraint min_len_value(2);
      constraint max_len_value(64);
    }
    required isPro: bool {
      rewrite insert using(false);
      default := false;
    }
    required isFounder: bool {
      rewrite insert using(false);
      default := false;
    }
    required isStaff: bool {
      rewrite insert using(false);
      default := false;
    }
    required followerCount: int32 {
      rewrite insert using(0);
      default := 0;
    }
    property followingCount: int32 {
      rewrite insert using(0);
      default := 0;
    }
    property isFollowing := (
      select exists (
        select Follow filter .follower.displayName = global currentUserDisplayName and .followee.id = User.id
      )
    );
  }

  type Post extending Record {
    required user: User {
      on target delete delete source;
    }
    content: str {
      constraint min_len_value(16);
      constraint max_len_value(1024);
    }
    required bookmarkCount: int32 {
      rewrite insert using(0);
      default := 0;
    }
    required favouriteCount: int32 {
      rewrite insert using(0);
      default := 0;
    }
    required repostCount: int32 {
      rewrite insert using(0);
      default := 0;
    }
    required quoteCount: int32 {
      rewrite insert using(0);
      default := 0;
    }
    required editCount: int16 {
      rewrite insert using(0);
      rewrite update using (
        __subject__.editCount + 1
        if __subject__.content != __old__.content
        else __subject__.editCount
      );
      default := 0;
    }
    property isBookmarked := (
      select exists (
        select Bookmark filter .post.id = Post.id and .user.displayName = global currentUserDisplayName
      )
    );
    property isFavourite := (
      select exists (
        select Favourite filter .post.id = Post.id and .user.displayName = global currentUserDisplayName
      )
    );
    property isReposted := exists (
      select Repost filter .post.id = Post.id and .user.displayName = global currentUserDisplayName
    );
    property isQuoted := exists (
      select Quote filter .quoteOf.id = Post.id and .user.displayName = global currentUserDisplayName
    );
    property hasEditAvailable := (
      with date := datetime_of_statement()
      select (date - .createdAt) < <std::duration>'72 hours' and
      .user.displayName = global currentUserDisplayName and .editCount <= (select if .user.isPro then 5 else 3)
    );
    repostOf: Post {
      on target delete delete source;
    }
    quoteOf: Post {
      on target delete allow;
    }
    updatedAt: datetime {
      rewrite update using(
        datetime_of_statement()
        if __subject__.content != __old__.content
        else __subject__.updatedAt
      );
    }

    trigger handle_content_edit after update for each
    when (__old__.content != __new__.content and __old__.hasEditAvailable)
    do (
      insert Edit {
        user := __old__.user,
        post := __old__,
        previousContent := __old__.content
      }
    )
  }

  type Edit extending Record {
    required user: User {
      on target delete delete source;
    }
    required post: Post {
      on target delete delete source;
    }
    required previousContent: str {
      constraint min_len_value(16);
      constraint max_len_value(1024);
    }
  }

  type Quote extending Record {
    required user: User {
      on target delete delete source;
    }
    required post: Post {
      on target delete delete source;
    }
    required quoteOf: Post {
      on target delete delete source;
    }

    trigger increment_quote_count after insert for each do (
      update Post 
      filter .id = __new__.quoteOf.id
      set { quoteCount := .quoteCount + 1 } 
    );

    trigger decrement_quote_count after delete for each do (
      update Post 
      filter .id = __old__.quoteOf.id
      set { quoteCount := .quoteCount - 1 } 
    );

    trigger notify_post_author after insert
    for each
    when (__new__.post.user.id != __new__.user.id)
    do (
      insert Notification {
        from := __new__.user,
        user := __new__.post.user,
        post := __new__.post,
        kind := NotificationKind.Quote
      }
    );
  }

  type Repost extending Record {
    required user: User {
      on target delete delete source;
    }
    required post: Post {
      on target delete delete source;
    }

    trigger create_repost_post after insert for each do (
      insert Post {
        user := __new__.user,
        content := __new__.post.content,
        repostOf := __new__.post
      }
    );

    trigger increment_repost_count after insert for each do (
      update Post 
      filter .id = __new__.post.id
      set { repostCount := .repostCount + 1 } 
    );

    trigger decrement_repost_count after delete for each do (
      update Post 
      filter .id = __old__.post.id
      set { repostCount := .repostCount - 1 } 
    );

    trigger notify_post_author after insert 
    for each
    when (__new__.post.user.id != __new__.user.id) 
    do (
      insert Notification {
        from := __new__.user,
        user := __new__.post.user,
        post := __new__.post,
        kind := NotificationKind.Repost
      }
    );
  }

  type Favourite extending Record {
    required user: User {
      on target delete delete source;
    }
    required post: Post {
      on target delete delete source;
    }
    required favouritedAt: datetime {
      rewrite insert using(datetime_of_statement());
      default := datetime_of_statement();
    }

    trigger increment_favourite_count after insert for each do (
      update Post 
      filter .id = __new__.post.id
      set { favouriteCount := .favouriteCount + 1 } 
    );

    trigger decrement_favourite_count after delete for each do (
      update Post 
      filter .id = __old__.post.id
      set { favouriteCount := .favouriteCount - 1 } 
    );

    trigger notify_post_author after insert 
    for each
    when (__new__.post.user.id != __new__.user.id) 
    do (
      insert Notification {
        from := __new__.user,
        user := __new__.post.user,
        post := __new__.post,
        kind := NotificationKind.Favourite
      }
    );

    constraint exclusive on (( .user, .post ));
  }

  type Bookmark extending Record {
    required user: User {
      on target delete delete source;
    }
    required post: Post {
      on target delete delete source;
    }
    required bookmarkedAt: datetime {
      rewrite insert using(datetime_of_statement());
      default := datetime_of_statement();
    }

    trigger increment_bookmark_count after insert for each do (
      update Post 
      filter .id = __new__.post.id
      set { bookmarkCount := .bookmarkCount + 1 } 
    );

    trigger decrement_bookmark_count after delete for each do (
      update Post 
      filter .id = __old__.post.id
      set { bookmarkCount := .bookmarkCount - 1 } 
    );

    constraint exclusive on (( .user, .post ));
  }

  type Follow extending Record {
    required follower: User {
      on target delete delete source;
    }
    required followee: User {
      on target delete delete source;
    }

    trigger increment_followee_followers after insert for each do (
      update User 
      filter .id = __new__.followee.id
      set { followerCount := .followerCount + 1 } 
    );

    trigger decrement_followee_followers after delete for each do (
      update User 
      filter .id = __old__.followee.id
      set { followerCount := .followerCount - 1 } 
    );

    trigger increment_follower_following after insert for each do (
      update User 
      filter .id = __new__.follower.id
      set { followingCount := .followingCount + 1 } 
    );

    trigger decrement_follower_following after delete for each do (
      update User 
      filter .id = __old__.follower.id
      set { followingCount := .followingCount - 1 } 
    );

    trigger notify_followee after insert for each do (
      insert Notification {
        from := __new__.follower,
        user := __new__.followee,
        kind := NotificationKind.Follow
      }
    );

    constraint exclusive on (( .follower, .followee ));
  }

  type Notification extending Record {
    required from: User {
      on target delete delete source;
    }
    required user: User {
      on target delete delete source;
    }
    post: Post {
      on target delete delete source;
    }
    required kind: NotificationKind;
    required isRead: bool {
      rewrite insert using(false);
      default := false;
    }
  }
}
